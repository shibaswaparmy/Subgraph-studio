// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Checkpoint extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Checkpoint entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Checkpoint must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Checkpoint", id.toString(), this);
    }
  }

  static load(id: string): Checkpoint | null {
    return changetype<Checkpoint | null>(store.get("Checkpoint", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    return value!.toBytes();
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get headerBlockId(): BigInt {
    let value = this.get("headerBlockId");
    return value!.toBigInt();
  }

  set headerBlockId(value: BigInt) {
    this.set("headerBlockId", Value.fromBigInt(value));
  }

  get checkpointNumber(): BigInt {
    let value = this.get("checkpointNumber");
    return value!.toBigInt();
  }

  set checkpointNumber(value: BigInt) {
    this.set("checkpointNumber", Value.fromBigInt(value));
  }

  get reward(): BigInt {
    let value = this.get("reward");
    return value!.toBigInt();
  }

  set reward(value: BigInt) {
    this.set("reward", Value.fromBigInt(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    return value!.toBigInt();
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get end(): BigInt {
    let value = this.get("end");
    return value!.toBigInt();
  }

  set end(value: BigInt) {
    this.set("end", Value.fromBigInt(value));
  }

  get root(): Bytes {
    let value = this.get("root");
    return value!.toBytes();
  }

  set root(value: Bytes) {
    this.set("root", Value.fromBytes(value));
  }

  get logIndex(): string {
    let value = this.get("logIndex");
    return value!.toString();
  }

  set logIndex(value: string) {
    this.set("logIndex", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }
}

export class StateSync extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StateSync entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StateSync must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StateSync", id.toString(), this);
    }
  }

  static load(id: string): StateSync | null {
    return changetype<StateSync | null>(store.get("StateSync", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get stateId(): BigInt {
    let value = this.get("stateId");
    return value!.toBigInt();
  }

  set stateId(value: BigInt) {
    this.set("stateId", Value.fromBigInt(value));
  }

  get contract(): Bytes {
    let value = this.get("contract");
    return value!.toBytes();
  }

  set contract(value: Bytes) {
    this.set("contract", Value.fromBytes(value));
  }

  get syncType(): i32 {
    let value = this.get("syncType");
    return value!.toI32();
  }

  set syncType(value: i32) {
    this.set("syncType", Value.fromI32(value));
  }

  get depositorOrRootToken(): string {
    let value = this.get("depositorOrRootToken");
    return value!.toString();
  }

  set depositorOrRootToken(value: string) {
    this.set("depositorOrRootToken", Value.fromString(value));
  }

  get depositedTokenOrChildToken(): string {
    let value = this.get("depositedTokenOrChildToken");
    return value!.toString();
  }

  set depositedTokenOrChildToken(value: string) {
    this.set("depositedTokenOrChildToken", Value.fromString(value));
  }

  get data(): string {
    let value = this.get("data");
    return value!.toString();
  }

  set data(value: string) {
    this.set("data", Value.fromString(value));
  }

  get rawData(): string {
    let value = this.get("rawData");
    return value!.toString();
  }

  set rawData(value: string) {
    this.set("rawData", Value.fromString(value));
  }

  get logIndex(): string {
    let value = this.get("logIndex");
    return value!.toString();
  }

  set logIndex(value: string) {
    this.set("logIndex", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    return value!.toBigInt();
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }
}

export class StateRegistration extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StateRegistration entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StateRegistration must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StateRegistration", id.toString(), this);
    }
  }

  static load(id: string): StateRegistration | null {
    return changetype<StateRegistration | null>(
      store.get("StateRegistration", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value!.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class PlasmaExit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PlasmaExit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PlasmaExit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PlasmaExit", id.toString(), this);
    }
  }

  static load(id: string): PlasmaExit | null {
    return changetype<PlasmaExit | null>(store.get("PlasmaExit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get exitId(): BigInt {
    let value = this.get("exitId");
    return value!.toBigInt();
  }

  set exitId(value: BigInt) {
    this.set("exitId", Value.fromBigInt(value));
  }

  get exitInitiator(): Bytes | null {
    let value = this.get("exitInitiator");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set exitInitiator(value: Bytes | null) {
    if (!value) {
      this.unset("exitInitiator");
    } else {
      this.set("exitInitiator", Value.fromBytes(<Bytes>value));
    }
  }

  get exitCompleter(): Bytes | null {
    let value = this.get("exitCompleter");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set exitCompleter(value: Bytes | null) {
    if (!value) {
      this.unset("exitCompleter");
    } else {
      this.set("exitCompleter", Value.fromBytes(<Bytes>value));
    }
  }

  get token(): Bytes | null {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set token(value: Bytes | null) {
    if (!value) {
      this.unset("token");
    } else {
      this.set("token", Value.fromBytes(<Bytes>value));
    }
  }

  get amount(): BigInt | null {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt | null) {
    if (!value) {
      this.unset("amount");
    } else {
      this.set("amount", Value.fromBigInt(<BigInt>value));
    }
  }

  get isRegularExit(): boolean {
    let value = this.get("isRegularExit");
    return value!.toBoolean();
  }

  set isRegularExit(value: boolean) {
    this.set("isRegularExit", Value.fromBoolean(value));
  }

  get exited(): i32 {
    let value = this.get("exited");
    return value!.toI32();
  }

  set exited(value: i32) {
    this.set("exited", Value.fromI32(value));
  }

  get exitStartedTxHash(): Bytes | null {
    let value = this.get("exitStartedTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set exitStartedTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("exitStartedTxHash");
    } else {
      this.set("exitStartedTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get exitStartedTimeStamp(): BigInt | null {
    let value = this.get("exitStartedTimeStamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set exitStartedTimeStamp(value: BigInt | null) {
    if (!value) {
      this.unset("exitStartedTimeStamp");
    } else {
      this.set("exitStartedTimeStamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get exitCancelledTxHash(): Bytes | null {
    let value = this.get("exitCancelledTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set exitCancelledTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("exitCancelledTxHash");
    } else {
      this.set("exitCancelledTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get exitCancelledTimeStamp(): BigInt | null {
    let value = this.get("exitCancelledTimeStamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set exitCancelledTimeStamp(value: BigInt | null) {
    if (!value) {
      this.unset("exitCancelledTimeStamp");
    } else {
      this.set("exitCancelledTimeStamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get exitCompletedTxHash(): Bytes | null {
    let value = this.get("exitCompletedTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set exitCompletedTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("exitCompletedTxHash");
    } else {
      this.set("exitCompletedTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get exitCompletedTimeStamp(): BigInt | null {
    let value = this.get("exitCompletedTimeStamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set exitCompletedTimeStamp(value: BigInt | null) {
    if (!value) {
      this.unset("exitCompletedTimeStamp");
    } else {
      this.set("exitCompletedTimeStamp", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class PredicateRegistration extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PredicateRegistration entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PredicateRegistration must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PredicateRegistration", id.toString(), this);
    }
  }

  static load(id: string): PredicateRegistration | null {
    return changetype<PredicateRegistration | null>(
      store.get("PredicateRegistration", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenType(): Bytes {
    let value = this.get("tokenType");
    return value!.toBytes();
  }

  set tokenType(value: Bytes) {
    this.set("tokenType", Value.fromBytes(value));
  }

  get predicateAddress(): Bytes {
    let value = this.get("predicateAddress");
    return value!.toBytes();
  }

  set predicateAddress(value: Bytes) {
    this.set("predicateAddress", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class TokenMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenMapping entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenMapping must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TokenMapping", id.toString(), this);
    }
  }

  static load(id: string): TokenMapping | null {
    return changetype<TokenMapping | null>(store.get("TokenMapping", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get rootToken(): Bytes {
    let value = this.get("rootToken");
    return value!.toBytes();
  }

  set rootToken(value: Bytes) {
    this.set("rootToken", Value.fromBytes(value));
  }

  get childToken(): Bytes {
    let value = this.get("childToken");
    return value!.toBytes();
  }

  set childToken(value: Bytes) {
    this.set("childToken", Value.fromBytes(value));
  }

  get tokenType(): string {
    let value = this.get("tokenType");
    return value!.toString();
  }

  set tokenType(value: string) {
    this.set("tokenType", Value.fromString(value));
  }

  get isPOS(): boolean {
    let value = this.get("isPOS");
    return value!.toBoolean();
  }

  set isPOS(value: boolean) {
    this.set("isPOS", Value.fromBoolean(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FxTokenMapping extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FxTokenMapping entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxTokenMapping must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxTokenMapping", id.toString(), this);
    }
  }

  static load(id: string): FxTokenMapping | null {
    return changetype<FxTokenMapping | null>(store.get("FxTokenMapping", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value!.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get rootToken(): Bytes {
    let value = this.get("rootToken");
    return value!.toBytes();
  }

  set rootToken(value: Bytes) {
    this.set("rootToken", Value.fromBytes(value));
  }

  get childToken(): Bytes {
    let value = this.get("childToken");
    return value!.toBytes();
  }

  set childToken(value: Bytes) {
    this.set("childToken", Value.fromBytes(value));
  }

  get tokenType(): string {
    let value = this.get("tokenType");
    return value!.toString();
  }

  set tokenType(value: string) {
    this.set("tokenType", Value.fromString(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FxTokenMappingCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save FxTokenMappingCounter entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxTokenMappingCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxTokenMappingCounter", id.toString(), this);
    }
  }

  static load(id: string): FxTokenMappingCounter | null {
    return changetype<FxTokenMappingCounter | null>(
      store.get("FxTokenMappingCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class FxDeposit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FxDeposit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxDeposit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxDeposit", id.toString(), this);
    }
  }

  static load(id: string): FxDeposit | null {
    return changetype<FxDeposit | null>(store.get("FxDeposit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value!.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get rootToken(): Bytes {
    let value = this.get("rootToken");
    return value!.toBytes();
  }

  set rootToken(value: Bytes) {
    this.set("rootToken", Value.fromBytes(value));
  }

  get tokenType(): string {
    let value = this.get("tokenType");
    return value!.toString();
  }

  set tokenType(value: string) {
    this.set("tokenType", Value.fromString(value));
  }

  get depositor(): Bytes {
    let value = this.get("depositor");
    return value!.toBytes();
  }

  set depositor(value: Bytes) {
    this.set("depositor", Value.fromBytes(value));
  }

  get userAddress(): Bytes {
    let value = this.get("userAddress");
    return value!.toBytes();
  }

  set userAddress(value: Bytes) {
    this.set("userAddress", Value.fromBytes(value));
  }

  get amount(): BigInt | null {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt | null) {
    if (!value) {
      this.unset("amount");
    } else {
      this.set("amount", Value.fromBigInt(<BigInt>value));
    }
  }

  get tokenId(): BigInt | null {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt | null) {
    if (!value) {
      this.unset("tokenId");
    } else {
      this.set("tokenId", Value.fromBigInt(<BigInt>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FxDepositCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FxDepositCounter entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxDepositCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxDepositCounter", id.toString(), this);
    }
  }

  static load(id: string): FxDepositCounter | null {
    return changetype<FxDepositCounter | null>(
      store.get("FxDepositCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class FxWithdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FxWithdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxWithdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxWithdraw", id.toString(), this);
    }
  }

  static load(id: string): FxWithdraw | null {
    return changetype<FxWithdraw | null>(store.get("FxWithdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value!.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get rootToken(): Bytes {
    let value = this.get("rootToken");
    return value!.toBytes();
  }

  set rootToken(value: Bytes) {
    this.set("rootToken", Value.fromBytes(value));
  }

  get childToken(): Bytes {
    let value = this.get("childToken");
    return value!.toBytes();
  }

  set childToken(value: Bytes) {
    this.set("childToken", Value.fromBytes(value));
  }

  get tokenType(): string {
    let value = this.get("tokenType");
    return value!.toString();
  }

  set tokenType(value: string) {
    this.set("tokenType", Value.fromString(value));
  }

  get userAddress(): Bytes {
    let value = this.get("userAddress");
    return value!.toBytes();
  }

  set userAddress(value: Bytes) {
    this.set("userAddress", Value.fromBytes(value));
  }

  get amount(): BigInt | null {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt | null) {
    if (!value) {
      this.unset("amount");
    } else {
      this.set("amount", Value.fromBigInt(<BigInt>value));
    }
  }

  get tokenId(): BigInt | null {
    let value = this.get("tokenId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set tokenId(value: BigInt | null) {
    if (!value) {
      this.unset("tokenId");
    } else {
      this.set("tokenId", Value.fromBigInt(<BigInt>value));
    }
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class FxWithdrawCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save FxWithdrawCounter entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type FxWithdrawCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("FxWithdrawCounter", id.toString(), this);
    }
  }

  static load(id: string): FxWithdrawCounter | null {
    return changetype<FxWithdrawCounter | null>(
      store.get("FxWithdrawCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class Validator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Validator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Validator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Validator", id.toString(), this);
    }
  }

  static load(id: string): Validator | null {
    return changetype<Validator | null>(store.get("Validator", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    return value!.toBytes();
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }

  get signerPubKey(): Bytes {
    let value = this.get("signerPubKey");
    return value!.toBytes();
  }

  set signerPubKey(value: Bytes) {
    this.set("signerPubKey", Value.fromBytes(value));
  }

  get liquidatedRewards(): BigInt {
    let value = this.get("liquidatedRewards");
    return value!.toBigInt();
  }

  set liquidatedRewards(value: BigInt) {
    this.set("liquidatedRewards", Value.fromBigInt(value));
  }

  get activationEpoch(): BigInt {
    let value = this.get("activationEpoch");
    return value!.toBigInt();
  }

  set activationEpoch(value: BigInt) {
    this.set("activationEpoch", Value.fromBigInt(value));
  }

  get deactivationEpoch(): BigInt {
    let value = this.get("deactivationEpoch");
    return value!.toBigInt();
  }

  set deactivationEpoch(value: BigInt) {
    this.set("deactivationEpoch", Value.fromBigInt(value));
  }

  get totalStaked(): BigInt {
    let value = this.get("totalStaked");
    return value!.toBigInt();
  }

  set totalStaked(value: BigInt) {
    this.set("totalStaked", Value.fromBigInt(value));
  }

  get selfStake(): BigInt {
    let value = this.get("selfStake");
    return value!.toBigInt();
  }

  set selfStake(value: BigInt) {
    this.set("selfStake", Value.fromBigInt(value));
  }

  get delegatedStake(): BigInt {
    let value = this.get("delegatedStake");
    return value!.toBigInt();
  }

  set delegatedStake(value: BigInt) {
    this.set("delegatedStake", Value.fromBigInt(value));
  }

  get commissionRate(): BigInt {
    let value = this.get("commissionRate");
    return value!.toBigInt();
  }

  set commissionRate(value: BigInt) {
    this.set("commissionRate", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get status(): i32 {
    let value = this.get("status");
    return value!.toI32();
  }

  set status(value: i32) {
    this.set("status", Value.fromI32(value));
  }

  get jailEndEpoch(): BigInt {
    let value = this.get("jailEndEpoch");
    return value!.toBigInt();
  }

  set jailEndEpoch(value: BigInt) {
    this.set("jailEndEpoch", Value.fromBigInt(value));
  }

  get auctionAmount(): BigInt {
    let value = this.get("auctionAmount");
    return value!.toBigInt();
  }

  set auctionAmount(value: BigInt) {
    this.set("auctionAmount", Value.fromBigInt(value));
  }

  get isInAuction(): boolean {
    let value = this.get("isInAuction");
    return value!.toBoolean();
  }

  set isInAuction(value: boolean) {
    this.set("isInAuction", Value.fromBoolean(value));
  }
}

export class StakeUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakeUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakeUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakeUpdate", id.toString(), this);
    }
  }

  static load(id: string): StakeUpdate | null {
    return changetype<StakeUpdate | null>(store.get("StakeUpdate", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get totalStaked(): BigInt {
    let value = this.get("totalStaked");
    return value!.toBigInt();
  }

  set totalStaked(value: BigInt) {
    this.set("totalStaked", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get logIndex(): BigInt {
    let value = this.get("logIndex");
    return value!.toBigInt();
  }

  set logIndex(value: BigInt) {
    this.set("logIndex", Value.fromBigInt(value));
  }
}

export class GlobalDelegatorCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save GlobalDelegatorCounter entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GlobalDelegatorCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GlobalDelegatorCounter", id.toString(), this);
    }
  }

  static load(id: string): GlobalDelegatorCounter | null {
    return changetype<GlobalDelegatorCounter | null>(
      store.get("GlobalDelegatorCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class GlobalPlasmaExitCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save GlobalPlasmaExitCounter entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GlobalPlasmaExitCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GlobalPlasmaExitCounter", id.toString(), this);
    }
  }

  static load(id: string): GlobalPlasmaExitCounter | null {
    return changetype<GlobalPlasmaExitCounter | null>(
      store.get("GlobalPlasmaExitCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class Delegator extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Delegator entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Delegator must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Delegator", id.toString(), this);
    }
  }

  static load(id: string): Delegator | null {
    return changetype<Delegator | null>(store.get("Delegator", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get delegatedAmount(): BigInt {
    let value = this.get("delegatedAmount");
    return value!.toBigInt();
  }

  set delegatedAmount(value: BigInt) {
    this.set("delegatedAmount", Value.fromBigInt(value));
  }

  get unclaimedAmount(): BigInt {
    let value = this.get("unclaimedAmount");
    return value!.toBigInt();
  }

  set unclaimedAmount(value: BigInt) {
    this.set("unclaimedAmount", Value.fromBigInt(value));
  }

  get claimedAmount(): BigInt {
    let value = this.get("claimedAmount");
    return value!.toBigInt();
  }

  set claimedAmount(value: BigInt) {
    this.set("claimedAmount", Value.fromBigInt(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }

  get claimedRewards(): BigInt {
    let value = this.get("claimedRewards");
    return value!.toBigInt();
  }

  set claimedRewards(value: BigInt) {
    this.set("claimedRewards", Value.fromBigInt(value));
  }
}

export class Topup extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Topup entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Topup must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Topup", id.toString(), this);
    }
  }

  static load(id: string): Topup | null {
    return changetype<Topup | null>(store.get("Topup", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get topupAmount(): BigInt {
    let value = this.get("topupAmount");
    return value!.toBigInt();
  }

  set topupAmount(value: BigInt) {
    this.set("topupAmount", Value.fromBigInt(value));
  }

  get withdrawAmount(): BigInt {
    let value = this.get("withdrawAmount");
    return value!.toBigInt();
  }

  set withdrawAmount(value: BigInt) {
    this.set("withdrawAmount", Value.fromBigInt(value));
  }
}

export class StakingParams extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingParams entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingParams must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingParams", id.toString(), this);
    }
  }

  static load(id: string): StakingParams | null {
    return changetype<StakingParams | null>(store.get("StakingParams", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes | null {
    let value = this.get("owner");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set owner(value: Bytes | null) {
    if (!value) {
      this.unset("owner");
    } else {
      this.set("owner", Value.fromBytes(<Bytes>value));
    }
  }

  get validatorThreshold(): BigInt {
    let value = this.get("validatorThreshold");
    return value!.toBigInt();
  }

  set validatorThreshold(value: BigInt) {
    this.set("validatorThreshold", Value.fromBigInt(value));
  }

  get proposerBonus(): BigInt {
    let value = this.get("proposerBonus");
    return value!.toBigInt();
  }

  set proposerBonus(value: BigInt) {
    this.set("proposerBonus", Value.fromBigInt(value));
  }

  get dynasty(): BigInt {
    let value = this.get("dynasty");
    return value!.toBigInt();
  }

  set dynasty(value: BigInt) {
    this.set("dynasty", Value.fromBigInt(value));
  }

  get liquidatedRewards(): BigInt {
    let value = this.get("liquidatedRewards");
    return value!.toBigInt();
  }

  set liquidatedRewards(value: BigInt) {
    this.set("liquidatedRewards", Value.fromBigInt(value));
  }
}

export class StakingNFTTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakingNFTTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingNFTTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingNFTTransfer", id.toString(), this);
    }
  }

  static load(id: string): StakingNFTTransfer | null {
    return changetype<StakingNFTTransfer | null>(
      store.get("StakingNFTTransfer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenId(): BigInt {
    let value = this.get("tokenId");
    return value!.toBigInt();
  }

  set tokenId(value: BigInt) {
    this.set("tokenId", Value.fromBigInt(value));
  }

  get currentOwner(): Bytes {
    let value = this.get("currentOwner");
    return value!.toBytes();
  }

  set currentOwner(value: Bytes) {
    this.set("currentOwner", Value.fromBytes(value));
  }

  get previousOwners(): Array<Bytes> {
    let value = this.get("previousOwners");
    return value!.toBytesArray();
  }

  set previousOwners(value: Array<Bytes>) {
    this.set("previousOwners", Value.fromBytesArray(value));
  }

  get transactionHashes(): Array<Bytes> {
    let value = this.get("transactionHashes");
    return value!.toBytesArray();
  }

  set transactionHashes(value: Array<Bytes>) {
    this.set("transactionHashes", Value.fromBytesArray(value));
  }
}

export class DelegatorUnbond extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegatorUnbond entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorUnbond must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorUnbond", id.toString(), this);
    }
  }

  static load(id: string): DelegatorUnbond | null {
    return changetype<DelegatorUnbond | null>(store.get("DelegatorUnbond", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }

  get completed(): boolean {
    let value = this.get("completed");
    return value!.toBoolean();
  }

  set completed(value: boolean) {
    this.set("completed", Value.fromBoolean(value));
  }

  get unbondStartedTxHash(): Bytes | null {
    let value = this.get("unbondStartedTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set unbondStartedTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("unbondStartedTxHash");
    } else {
      this.set("unbondStartedTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get unbondStartedTimeStamp(): BigInt | null {
    let value = this.get("unbondStartedTimeStamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set unbondStartedTimeStamp(value: BigInt | null) {
    if (!value) {
      this.unset("unbondStartedTimeStamp");
    } else {
      this.set("unbondStartedTimeStamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get unbondClaimedTxHash(): Bytes | null {
    let value = this.get("unbondClaimedTxHash");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set unbondClaimedTxHash(value: Bytes | null) {
    if (!value) {
      this.unset("unbondClaimedTxHash");
    } else {
      this.set("unbondClaimedTxHash", Value.fromBytes(<Bytes>value));
    }
  }

  get unbondClaimedTimeStamp(): BigInt | null {
    let value = this.get("unbondClaimedTimeStamp");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set unbondClaimedTimeStamp(value: BigInt | null) {
    if (!value) {
      this.unset("unbondClaimedTimeStamp");
    } else {
      this.set("unbondClaimedTimeStamp", Value.fromBigInt(<BigInt>value));
    }
  }

  get activeStake(): BigInt {
    let value = this.get("activeStake");
    return value!.toBigInt();
  }

  set activeStake(value: BigInt) {
    this.set("activeStake", Value.fromBigInt(value));
  }
}

export class MaticTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save MaticTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MaticTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MaticTransfer", id.toString(), this);
    }
  }

  static load(id: string): MaticTransfer | null {
    return changetype<MaticTransfer | null>(store.get("MaticTransfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class GlobalDelegationCounter extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save GlobalDelegationCounter entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GlobalDelegationCounter must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GlobalDelegationCounter", id.toString(), this);
    }
  }

  static load(id: string): GlobalDelegationCounter | null {
    return changetype<GlobalDelegationCounter | null>(
      store.get("GlobalDelegationCounter", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get current(): BigInt {
    let value = this.get("current");
    return value!.toBigInt();
  }

  set current(value: BigInt) {
    this.set("current", Value.fromBigInt(value));
  }
}

export class Delegation extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Delegation entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Delegation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Delegation", id.toString(), this);
    }
  }

  static load(id: string): Delegation | null {
    return changetype<Delegation | null>(store.get("Delegation", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get counter(): BigInt {
    let value = this.get("counter");
    return value!.toBigInt();
  }

  set counter(value: BigInt) {
    this.set("counter", Value.fromBigInt(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get activeStake(): BigInt {
    let value = this.get("activeStake");
    return value!.toBigInt();
  }

  set activeStake(value: BigInt) {
    this.set("activeStake", Value.fromBigInt(value));
  }
}

export class ValidatorClaimReward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ValidatorClaimReward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ValidatorClaimReward must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ValidatorClaimReward", id.toString(), this);
    }
  }

  static load(id: string): ValidatorClaimReward | null {
    return changetype<ValidatorClaimReward | null>(
      store.get("ValidatorClaimReward", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get totalAmount(): BigInt {
    let value = this.get("totalAmount");
    return value!.toBigInt();
  }

  set totalAmount(value: BigInt) {
    this.set("totalAmount", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class ValidatorRestake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ValidatorRestake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ValidatorRestake must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ValidatorRestake", id.toString(), this);
    }
  }

  static load(id: string): ValidatorRestake | null {
    return changetype<ValidatorRestake | null>(
      store.get("ValidatorRestake", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    return value!.toBytes();
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get totalAmount(): BigInt {
    let value = this.get("totalAmount");
    return value!.toBigInt();
  }

  set totalAmount(value: BigInt) {
    this.set("totalAmount", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DelegatorClaimReward extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegatorClaimReward entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorClaimReward must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorClaimReward", id.toString(), this);
    }
  }

  static load(id: string): DelegatorClaimReward | null {
    return changetype<DelegatorClaimReward | null>(
      store.get("DelegatorClaimReward", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get rewards(): BigInt {
    let value = this.get("rewards");
    return value!.toBigInt();
  }

  set rewards(value: BigInt) {
    this.set("rewards", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class DelegatorRestake extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegatorRestake entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorRestake must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorRestake", id.toString(), this);
    }
  }

  static load(id: string): DelegatorRestake | null {
    return changetype<DelegatorRestake | null>(
      store.get("DelegatorRestake", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get totalStaked(): BigInt {
    let value = this.get("totalStaked");
    return value!.toBigInt();
  }

  set totalStaked(value: BigInt) {
    this.set("totalStaked", Value.fromBigInt(value));
  }

  get block(): BigInt {
    let value = this.get("block");
    return value!.toBigInt();
  }

  set block(value: BigInt) {
    this.set("block", Value.fromBigInt(value));
  }

  get timestamp(): BigInt {
    let value = this.get("timestamp");
    return value!.toBigInt();
  }

  set timestamp(value: BigInt) {
    this.set("timestamp", Value.fromBigInt(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    return value!.toBytes();
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}
