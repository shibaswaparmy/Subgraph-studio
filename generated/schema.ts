// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class ExampleEntity extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExampleEntity entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExampleEntity must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExampleEntity", id.toString(), this);
    }
  }

  static load(id: string): ExampleEntity | null {
    return changetype<ExampleEntity | null>(store.get("ExampleEntity", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get count(): BigInt {
    let value = this.get("count");
    return value!.toBigInt();
  }

  set count(value: BigInt) {
    this.set("count", Value.fromBigInt(value));
  }

  get proposer(): Bytes {
    let value = this.get("proposer");
    return value!.toBytes();
  }

  set proposer(value: Bytes) {
    this.set("proposer", Value.fromBytes(value));
  }

  get headerBlockId(): BigInt {
    let value = this.get("headerBlockId");
    return value!.toBigInt();
  }

  set headerBlockId(value: BigInt) {
    this.set("headerBlockId", Value.fromBigInt(value));
  }
}

export class StakeManagerOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StakeManagerOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakeManagerOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakeManagerOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): StakeManagerOwnershipTransferred | null {
    return changetype<StakeManagerOwnershipTransferred | null>(
      store.get("StakeManagerOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class RootChainChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RootChainChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RootChainChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RootChainChanged", id.toString(), this);
    }
  }

  static load(id: string): RootChainChanged | null {
    return changetype<RootChainChanged | null>(
      store.get("RootChainChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousRootChain(): Bytes {
    let value = this.get("previousRootChain");
    return value!.toBytes();
  }

  set previousRootChain(value: Bytes) {
    this.set("previousRootChain", Value.fromBytes(value));
  }

  get newRootChain(): Bytes {
    let value = this.get("newRootChain");
    return value!.toBytes();
  }

  set newRootChain(value: Bytes) {
    this.set("newRootChain", Value.fromBytes(value));
  }
}

export class ExitCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitCancelled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitCancelled", id.toString(), this);
    }
  }

  static load(id: string): ExitCancelled | null {
    return changetype<ExitCancelled | null>(store.get("ExitCancelled", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get exitId(): BigInt {
    let value = this.get("exitId");
    return value!.toBigInt();
  }

  set exitId(value: BigInt) {
    this.set("exitId", Value.fromBigInt(value));
  }
}

export class ExitPeriodUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitPeriodUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitPeriodUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitPeriodUpdate", id.toString(), this);
    }
  }

  static load(id: string): ExitPeriodUpdate | null {
    return changetype<ExitPeriodUpdate | null>(
      store.get("ExitPeriodUpdate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldExitPeriod(): BigInt {
    let value = this.get("oldExitPeriod");
    return value!.toBigInt();
  }

  set oldExitPeriod(value: BigInt) {
    this.set("oldExitPeriod", Value.fromBigInt(value));
  }

  get newExitPeriod(): BigInt {
    let value = this.get("newExitPeriod");
    return value!.toBigInt();
  }

  set newExitPeriod(value: BigInt) {
    this.set("newExitPeriod", Value.fromBigInt(value));
  }
}

export class ExitStarted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitStarted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitStarted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitStarted", id.toString(), this);
    }
  }

  static load(id: string): ExitStarted | null {
    return changetype<ExitStarted | null>(store.get("ExitStarted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get exitor(): Bytes {
    let value = this.get("exitor");
    return value!.toBytes();
  }

  set exitor(value: Bytes) {
    this.set("exitor", Value.fromBytes(value));
  }

  get exitId(): BigInt {
    let value = this.get("exitId");
    return value!.toBigInt();
  }

  set exitId(value: BigInt) {
    this.set("exitId", Value.fromBigInt(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get isRegularExit(): boolean {
    let value = this.get("isRegularExit");
    return value!.toBoolean();
  }

  set isRegularExit(value: boolean) {
    this.set("isRegularExit", Value.fromBoolean(value));
  }
}

export class ExitUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ExitUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ExitUpdated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ExitUpdated", id.toString(), this);
    }
  }

  static load(id: string): ExitUpdated | null {
    return changetype<ExitUpdated | null>(store.get("ExitUpdated", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get exitId(): BigInt {
    let value = this.get("exitId");
    return value!.toBigInt();
  }

  set exitId(value: BigInt) {
    this.set("exitId", Value.fromBigInt(value));
  }

  get age(): BigInt {
    let value = this.get("age");
    return value!.toBigInt();
  }

  set age(value: BigInt) {
    this.set("age", Value.fromBigInt(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    return value!.toBytes();
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }
}

export class WithdrawManagerOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save WithdrawManagerOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type WithdrawManagerOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("WithdrawManagerOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): WithdrawManagerOwnershipTransferred | null {
    return changetype<WithdrawManagerOwnershipTransferred | null>(
      store.get("WithdrawManagerOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Withdraw extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Withdraw entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Withdraw must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Withdraw", id.toString(), this);
    }
  }

  static load(id: string): Withdraw | null {
    return changetype<Withdraw | null>(store.get("Withdraw", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get exitId(): BigInt {
    let value = this.get("exitId");
    return value!.toBigInt();
  }

  set exitId(value: BigInt) {
    this.set("exitId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class MaxErc20DepositUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MaxErc20DepositUpdate entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MaxErc20DepositUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MaxErc20DepositUpdate", id.toString(), this);
    }
  }

  static load(id: string): MaxErc20DepositUpdate | null {
    return changetype<MaxErc20DepositUpdate | null>(
      store.get("MaxErc20DepositUpdate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get oldLimit(): BigInt {
    let value = this.get("oldLimit");
    return value!.toBigInt();
  }

  set oldLimit(value: BigInt) {
    this.set("oldLimit", Value.fromBigInt(value));
  }

  get newLimit(): BigInt {
    let value = this.get("newLimit");
    return value!.toBigInt();
  }

  set newLimit(value: BigInt) {
    this.set("newLimit", Value.fromBigInt(value));
  }
}

export class NewDepositBlock extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewDepositBlock entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NewDepositBlock must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewDepositBlock", id.toString(), this);
    }
  }

  static load(id: string): NewDepositBlock | null {
    return changetype<NewDepositBlock | null>(store.get("NewDepositBlock", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get token(): Bytes {
    let value = this.get("token");
    return value!.toBytes();
  }

  set token(value: Bytes) {
    this.set("token", Value.fromBytes(value));
  }

  get amountOrNFTId(): BigInt {
    let value = this.get("amountOrNFTId");
    return value!.toBigInt();
  }

  set amountOrNFTId(value: BigInt) {
    this.set("amountOrNFTId", Value.fromBigInt(value));
  }

  get depositBlockId(): BigInt {
    let value = this.get("depositBlockId");
    return value!.toBigInt();
  }

  set depositBlockId(value: BigInt) {
    this.set("depositBlockId", Value.fromBigInt(value));
  }
}

export class DepositManagerOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DepositManagerOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DepositManagerOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DepositManagerOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): DepositManagerOwnershipTransferred | null {
    return changetype<DepositManagerOwnershipTransferred | null>(
      store.get("DepositManagerOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class DelegatorUnstakeWithId extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DelegatorUnstakeWithId entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorUnstakeWithId must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorUnstakeWithId", id.toString(), this);
    }
  }

  static load(id: string): DelegatorUnstakeWithId | null {
    return changetype<DelegatorUnstakeWithId | null>(
      store.get("DelegatorUnstakeWithId", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }
}

export class RewardParams extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardParams entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardParams must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RewardParams", id.toString(), this);
    }
  }

  static load(id: string): RewardParams | null {
    return changetype<RewardParams | null>(store.get("RewardParams", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get rewardDecreasePerCheckpoint(): BigInt {
    let value = this.get("rewardDecreasePerCheckpoint");
    return value!.toBigInt();
  }

  set rewardDecreasePerCheckpoint(value: BigInt) {
    this.set("rewardDecreasePerCheckpoint", Value.fromBigInt(value));
  }

  get maxRewardedCheckpoints(): BigInt {
    let value = this.get("maxRewardedCheckpoints");
    return value!.toBigInt();
  }

  set maxRewardedCheckpoints(value: BigInt) {
    this.set("maxRewardedCheckpoints", Value.fromBigInt(value));
  }

  get checkpointRewardDelta(): BigInt {
    let value = this.get("checkpointRewardDelta");
    return value!.toBigInt();
  }

  set checkpointRewardDelta(value: BigInt) {
    this.set("checkpointRewardDelta", Value.fromBigInt(value));
  }
}

export class ShareBurnedWithId extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ShareBurnedWithId entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ShareBurnedWithId must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ShareBurnedWithId", id.toString(), this);
    }
  }

  static load(id: string): ShareBurnedWithId | null {
    return changetype<ShareBurnedWithId | null>(
      store.get("ShareBurnedWithId", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }
}

export class UpdateCommissionRate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UpdateCommissionRate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UpdateCommissionRate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UpdateCommissionRate", id.toString(), this);
    }
  }

  static load(id: string): UpdateCommissionRate | null {
    return changetype<UpdateCommissionRate | null>(
      store.get("UpdateCommissionRate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get newCommissionRate(): BigInt {
    let value = this.get("newCommissionRate");
    return value!.toBigInt();
  }

  set newCommissionRate(value: BigInt) {
    this.set("newCommissionRate", Value.fromBigInt(value));
  }

  get oldCommissionRate(): BigInt {
    let value = this.get("oldCommissionRate");
    return value!.toBigInt();
  }

  set oldCommissionRate(value: BigInt) {
    this.set("oldCommissionRate", Value.fromBigInt(value));
  }
}

export class GovernanceOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save GovernanceOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type GovernanceOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("GovernanceOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): GovernanceOwnershipTransferred | null {
    return changetype<GovernanceOwnershipTransferred | null>(
      store.get("GovernanceOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Approval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Approval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Approval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Approval", id.toString(), this);
    }
  }

  static load(id: string): Approval | null {
    return changetype<Approval | null>(store.get("Approval", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class ValidatorShareOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save ValidatorShareOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ValidatorShareOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ValidatorShareOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): ValidatorShareOwnershipTransferred | null {
    return changetype<ValidatorShareOwnershipTransferred | null>(
      store.get("ValidatorShareOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class Transfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Transfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Transfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Transfer", id.toString(), this);
    }
  }

  static load(id: string): Transfer | null {
    return changetype<Transfer | null>(store.get("Transfer", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class ClaimFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClaimFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ClaimFee must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ClaimFee", id.toString(), this);
    }
  }

  static load(id: string): ClaimFee | null {
    return changetype<ClaimFee | null>(store.get("ClaimFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }
}

export class ClaimRewards extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ClaimRewards entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ClaimRewards must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ClaimRewards", id.toString(), this);
    }
  }

  static load(id: string): ClaimRewards | null {
    return changetype<ClaimRewards | null>(store.get("ClaimRewards", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get totalAmount(): BigInt {
    let value = this.get("totalAmount");
    return value!.toBigInt();
  }

  set totalAmount(value: BigInt) {
    this.set("totalAmount", Value.fromBigInt(value));
  }
}

export class ConfirmAuction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ConfirmAuction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ConfirmAuction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ConfirmAuction", id.toString(), this);
    }
  }

  static load(id: string): ConfirmAuction | null {
    return changetype<ConfirmAuction | null>(store.get("ConfirmAuction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newValidatorId(): BigInt {
    let value = this.get("newValidatorId");
    return value!.toBigInt();
  }

  set newValidatorId(value: BigInt) {
    this.set("newValidatorId", Value.fromBigInt(value));
  }

  get oldValidatorId(): BigInt {
    let value = this.get("oldValidatorId");
    return value!.toBigInt();
  }

  set oldValidatorId(value: BigInt) {
    this.set("oldValidatorId", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class DelegatorClaimedRewards extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save DelegatorClaimedRewards entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorClaimedRewards must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorClaimedRewards", id.toString(), this);
    }
  }

  static load(id: string): DelegatorClaimedRewards | null {
    return changetype<DelegatorClaimedRewards | null>(
      store.get("DelegatorClaimedRewards", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get rewards(): BigInt {
    let value = this.get("rewards");
    return value!.toBigInt();
  }

  set rewards(value: BigInt) {
    this.set("rewards", Value.fromBigInt(value));
  }
}

export class DelegatorRestaked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegatorRestaked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorRestaked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorRestaked", id.toString(), this);
    }
  }

  static load(id: string): DelegatorRestaked | null {
    return changetype<DelegatorRestaked | null>(
      store.get("DelegatorRestaked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get totalStaked(): BigInt {
    let value = this.get("totalStaked");
    return value!.toBigInt();
  }

  set totalStaked(value: BigInt) {
    this.set("totalStaked", Value.fromBigInt(value));
  }
}

export class DelegatorUnstaked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegatorUnstaked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegatorUnstaked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegatorUnstaked", id.toString(), this);
    }
  }

  static load(id: string): DelegatorUnstaked | null {
    return changetype<DelegatorUnstaked | null>(
      store.get("DelegatorUnstaked", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class DynastyValueChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DynastyValueChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DynastyValueChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DynastyValueChange", id.toString(), this);
    }
  }

  static load(id: string): DynastyValueChange | null {
    return changetype<DynastyValueChange | null>(
      store.get("DynastyValueChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newDynasty(): BigInt {
    let value = this.get("newDynasty");
    return value!.toBigInt();
  }

  set newDynasty(value: BigInt) {
    this.set("newDynasty", Value.fromBigInt(value));
  }

  get oldDynasty(): BigInt {
    let value = this.get("oldDynasty");
    return value!.toBigInt();
  }

  set oldDynasty(value: BigInt) {
    this.set("oldDynasty", Value.fromBigInt(value));
  }
}

export class Jailed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Jailed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Jailed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Jailed", id.toString(), this);
    }
  }

  static load(id: string): Jailed | null {
    return changetype<Jailed | null>(store.get("Jailed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get exitEpoch(): BigInt {
    let value = this.get("exitEpoch");
    return value!.toBigInt();
  }

  set exitEpoch(value: BigInt) {
    this.set("exitEpoch", Value.fromBigInt(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    return value!.toBytes();
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }
}

export class StakingInfoOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StakingInfoOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingInfoOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingInfoOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): StakingInfoOwnershipTransferred | null {
    return changetype<StakingInfoOwnershipTransferred | null>(
      store.get("StakingInfoOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class ProposerBonusChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ProposerBonusChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ProposerBonusChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ProposerBonusChange", id.toString(), this);
    }
  }

  static load(id: string): ProposerBonusChange | null {
    return changetype<ProposerBonusChange | null>(
      store.get("ProposerBonusChange", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newProposerBonus(): BigInt {
    let value = this.get("newProposerBonus");
    return value!.toBigInt();
  }

  set newProposerBonus(value: BigInt) {
    this.set("newProposerBonus", Value.fromBigInt(value));
  }

  get oldProposerBonus(): BigInt {
    let value = this.get("oldProposerBonus");
    return value!.toBigInt();
  }

  set oldProposerBonus(value: BigInt) {
    this.set("oldProposerBonus", Value.fromBigInt(value));
  }
}

export class Restaked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Restaked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Restaked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Restaked", id.toString(), this);
    }
  }

  static load(id: string): Restaked | null {
    return changetype<Restaked | null>(store.get("Restaked", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get total(): BigInt {
    let value = this.get("total");
    return value!.toBigInt();
  }

  set total(value: BigInt) {
    this.set("total", Value.fromBigInt(value));
  }
}

export class RewardUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RewardUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RewardUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RewardUpdate", id.toString(), this);
    }
  }

  static load(id: string): RewardUpdate | null {
    return changetype<RewardUpdate | null>(store.get("RewardUpdate", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newReward(): BigInt {
    let value = this.get("newReward");
    return value!.toBigInt();
  }

  set newReward(value: BigInt) {
    this.set("newReward", Value.fromBigInt(value));
  }

  get oldReward(): BigInt {
    let value = this.get("oldReward");
    return value!.toBigInt();
  }

  set oldReward(value: BigInt) {
    this.set("oldReward", Value.fromBigInt(value));
  }
}

export class ShareBurned extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ShareBurned entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ShareBurned must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ShareBurned", id.toString(), this);
    }
  }

  static load(id: string): ShareBurned | null {
    return changetype<ShareBurned | null>(store.get("ShareBurned", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }
}

export class ShareMinted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ShareMinted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ShareMinted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ShareMinted", id.toString(), this);
    }
  }

  static load(id: string): ShareMinted | null {
    return changetype<ShareMinted | null>(store.get("ShareMinted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get tokens(): BigInt {
    let value = this.get("tokens");
    return value!.toBigInt();
  }

  set tokens(value: BigInt) {
    this.set("tokens", Value.fromBigInt(value));
  }
}

export class SignerChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save SignerChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type SignerChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("SignerChange", id.toString(), this);
    }
  }

  static load(id: string): SignerChange | null {
    return changetype<SignerChange | null>(store.get("SignerChange", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get oldSigner(): Bytes {
    let value = this.get("oldSigner");
    return value!.toBytes();
  }

  set oldSigner(value: Bytes) {
    this.set("oldSigner", Value.fromBytes(value));
  }

  get newSigner(): Bytes {
    let value = this.get("newSigner");
    return value!.toBytes();
  }

  set newSigner(value: Bytes) {
    this.set("newSigner", Value.fromBytes(value));
  }

  get signerPubkey(): Bytes {
    let value = this.get("signerPubkey");
    return value!.toBytes();
  }

  set signerPubkey(value: Bytes) {
    this.set("signerPubkey", Value.fromBytes(value));
  }
}

export class Slashed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Slashed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Slashed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Slashed", id.toString(), this);
    }
  }

  static load(id: string): Slashed | null {
    return changetype<Slashed | null>(store.get("Slashed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class StakeUpdate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StakeUpdate entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakeUpdate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakeUpdate", id.toString(), this);
    }
  }

  static load(id: string): StakeUpdate | null {
    return changetype<StakeUpdate | null>(store.get("StakeUpdate", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get newAmount(): BigInt {
    let value = this.get("newAmount");
    return value!.toBigInt();
  }

  set newAmount(value: BigInt) {
    this.set("newAmount", Value.fromBigInt(value));
  }
}

export class Staked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Staked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Staked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Staked", id.toString(), this);
    }
  }

  static load(id: string): Staked | null {
    return changetype<Staked | null>(store.get("Staked", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    return value!.toBytes();
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get activationEpoch(): BigInt {
    let value = this.get("activationEpoch");
    return value!.toBigInt();
  }

  set activationEpoch(value: BigInt) {
    this.set("activationEpoch", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get total(): BigInt {
    let value = this.get("total");
    return value!.toBigInt();
  }

  set total(value: BigInt) {
    this.set("total", Value.fromBigInt(value));
  }

  get signerPubkey(): Bytes {
    let value = this.get("signerPubkey");
    return value!.toBytes();
  }

  set signerPubkey(value: Bytes) {
    this.set("signerPubkey", Value.fromBytes(value));
  }
}

export class StartAuction extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StartAuction entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StartAuction must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StartAuction", id.toString(), this);
    }
  }

  static load(id: string): StartAuction | null {
    return changetype<StartAuction | null>(store.get("StartAuction", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get auctionAmount(): BigInt {
    let value = this.get("auctionAmount");
    return value!.toBigInt();
  }

  set auctionAmount(value: BigInt) {
    this.set("auctionAmount", Value.fromBigInt(value));
  }
}

export class ThresholdChange extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ThresholdChange entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ThresholdChange must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ThresholdChange", id.toString(), this);
    }
  }

  static load(id: string): ThresholdChange | null {
    return changetype<ThresholdChange | null>(store.get("ThresholdChange", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get newThreshold(): BigInt {
    let value = this.get("newThreshold");
    return value!.toBigInt();
  }

  set newThreshold(value: BigInt) {
    this.set("newThreshold", Value.fromBigInt(value));
  }

  get oldThreshold(): BigInt {
    let value = this.get("oldThreshold");
    return value!.toBigInt();
  }

  set oldThreshold(value: BigInt) {
    this.set("oldThreshold", Value.fromBigInt(value));
  }
}

export class TopUpFee extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TopUpFee entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TopUpFee must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TopUpFee", id.toString(), this);
    }
  }

  static load(id: string): TopUpFee | null {
    return changetype<TopUpFee | null>(store.get("TopUpFee", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get fee(): BigInt {
    let value = this.get("fee");
    return value!.toBigInt();
  }

  set fee(value: BigInt) {
    this.set("fee", Value.fromBigInt(value));
  }
}

export class UnJailed extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnJailed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UnJailed must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnJailed", id.toString(), this);
    }
  }

  static load(id: string): UnJailed | null {
    return changetype<UnJailed | null>(store.get("UnJailed", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get signer(): Bytes {
    let value = this.get("signer");
    return value!.toBytes();
  }

  set signer(value: Bytes) {
    this.set("signer", Value.fromBytes(value));
  }
}

export class UnstakeInit extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save UnstakeInit entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type UnstakeInit must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("UnstakeInit", id.toString(), this);
    }
  }

  static load(id: string): UnstakeInit | null {
    return changetype<UnstakeInit | null>(store.get("UnstakeInit", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get nonce(): BigInt {
    let value = this.get("nonce");
    return value!.toBigInt();
  }

  set nonce(value: BigInt) {
    this.set("nonce", Value.fromBigInt(value));
  }

  get deactivationEpoch(): BigInt {
    let value = this.get("deactivationEpoch");
    return value!.toBigInt();
  }

  set deactivationEpoch(value: BigInt) {
    this.set("deactivationEpoch", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class Unstaked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Unstaked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Unstaked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Unstaked", id.toString(), this);
    }
  }

  static load(id: string): Unstaked | null {
    return changetype<Unstaked | null>(store.get("Unstaked", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    return value!.toBigInt();
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }

  get total(): BigInt {
    let value = this.get("total");
    return value!.toBigInt();
  }

  set total(value: BigInt) {
    this.set("total", Value.fromBigInt(value));
  }
}

export class StakingInfoUpdateCommissionRate extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StakingInfoUpdateCommissionRate entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StakingInfoUpdateCommissionRate must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StakingInfoUpdateCommissionRate", id.toString(), this);
    }
  }

  static load(id: string): StakingInfoUpdateCommissionRate | null {
    return changetype<StakingInfoUpdateCommissionRate | null>(
      store.get("StakingInfoUpdateCommissionRate", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get validatorId(): BigInt {
    let value = this.get("validatorId");
    return value!.toBigInt();
  }

  set validatorId(value: BigInt) {
    this.set("validatorId", Value.fromBigInt(value));
  }

  get newCommissionRate(): BigInt {
    let value = this.get("newCommissionRate");
    return value!.toBigInt();
  }

  set newCommissionRate(value: BigInt) {
    this.set("newCommissionRate", Value.fromBigInt(value));
  }

  get oldCommissionRate(): BigInt {
    let value = this.get("oldCommissionRate");
    return value!.toBigInt();
  }

  set oldCommissionRate(value: BigInt) {
    this.set("oldCommissionRate", Value.fromBigInt(value));
  }
}

export class BoneTokenApproval extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BoneTokenApproval entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BoneTokenApproval must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BoneTokenApproval", id.toString(), this);
    }
  }

  static load(id: string): BoneTokenApproval | null {
    return changetype<BoneTokenApproval | null>(
      store.get("BoneTokenApproval", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get owner(): Bytes {
    let value = this.get("owner");
    return value!.toBytes();
  }

  set owner(value: Bytes) {
    this.set("owner", Value.fromBytes(value));
  }

  get spender(): Bytes {
    let value = this.get("spender");
    return value!.toBytes();
  }

  set spender(value: Bytes) {
    this.set("spender", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class DelegateChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegateChanged", id.toString(), this);
    }
  }

  static load(id: string): DelegateChanged | null {
    return changetype<DelegateChanged | null>(store.get("DelegateChanged", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get delegator(): Bytes {
    let value = this.get("delegator");
    return value!.toBytes();
  }

  set delegator(value: Bytes) {
    this.set("delegator", Value.fromBytes(value));
  }

  get fromDelegate(): Bytes {
    let value = this.get("fromDelegate");
    return value!.toBytes();
  }

  set fromDelegate(value: Bytes) {
    this.set("fromDelegate", Value.fromBytes(value));
  }

  get toDelegate(): Bytes {
    let value = this.get("toDelegate");
    return value!.toBytes();
  }

  set toDelegate(value: Bytes) {
    this.set("toDelegate", Value.fromBytes(value));
  }
}

export class DelegateVotesChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DelegateVotesChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DelegateVotesChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DelegateVotesChanged", id.toString(), this);
    }
  }

  static load(id: string): DelegateVotesChanged | null {
    return changetype<DelegateVotesChanged | null>(
      store.get("DelegateVotesChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get delegate(): Bytes {
    let value = this.get("delegate");
    return value!.toBytes();
  }

  set delegate(value: Bytes) {
    this.set("delegate", Value.fromBytes(value));
  }

  get previousBalance(): BigInt {
    let value = this.get("previousBalance");
    return value!.toBigInt();
  }

  set previousBalance(value: BigInt) {
    this.set("previousBalance", Value.fromBigInt(value));
  }

  get newBalance(): BigInt {
    let value = this.get("newBalance");
    return value!.toBigInt();
  }

  set newBalance(value: BigInt) {
    this.set("newBalance", Value.fromBigInt(value));
  }
}

export class BoneTokenOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save BoneTokenOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BoneTokenOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BoneTokenOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): BoneTokenOwnershipTransferred | null {
    return changetype<BoneTokenOwnershipTransferred | null>(
      store.get("BoneTokenOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class BoneTokenTransfer extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BoneTokenTransfer entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BoneTokenTransfer must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("BoneTokenTransfer", id.toString(), this);
    }
  }

  static load(id: string): BoneTokenTransfer | null {
    return changetype<BoneTokenTransfer | null>(
      store.get("BoneTokenTransfer", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get from(): Bytes {
    let value = this.get("from");
    return value!.toBytes();
  }

  set from(value: Bytes) {
    this.set("from", Value.fromBytes(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    return value!.toBytes();
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get value(): BigInt {
    let value = this.get("value");
    return value!.toBigInt();
  }

  set value(value: BigInt) {
    this.set("value", Value.fromBigInt(value));
  }
}

export class NewRegistration extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NewRegistration entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NewRegistration must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NewRegistration", id.toString(), this);
    }
  }

  static load(id: string): NewRegistration | null {
    return changetype<NewRegistration | null>(store.get("NewRegistration", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value!.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }
}

export class StateSenderOwnershipTransferred extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save StateSenderOwnershipTransferred entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StateSenderOwnershipTransferred must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StateSenderOwnershipTransferred", id.toString(), this);
    }
  }

  static load(id: string): StateSenderOwnershipTransferred | null {
    return changetype<StateSenderOwnershipTransferred | null>(
      store.get("StateSenderOwnershipTransferred", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get previousOwner(): Bytes {
    let value = this.get("previousOwner");
    return value!.toBytes();
  }

  set previousOwner(value: Bytes) {
    this.set("previousOwner", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    return value!.toBytes();
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }
}

export class RegistrationUpdated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RegistrationUpdated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RegistrationUpdated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RegistrationUpdated", id.toString(), this);
    }
  }

  static load(id: string): RegistrationUpdated | null {
    return changetype<RegistrationUpdated | null>(
      store.get("RegistrationUpdated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    return value!.toBytes();
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }

  get receiver(): Bytes {
    let value = this.get("receiver");
    return value!.toBytes();
  }

  set receiver(value: Bytes) {
    this.set("receiver", Value.fromBytes(value));
  }
}

export class StateSynced extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save StateSynced entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type StateSynced must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("StateSynced", id.toString(), this);
    }
  }

  static load(id: string): StateSynced | null {
    return changetype<StateSynced | null>(store.get("StateSynced", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get id(): BigInt {
    let value = this.get("id");
    return value!.toBigInt();
  }

  set id(value: BigInt) {
    this.set("id", Value.fromBigInt(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    return value!.toBytes();
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get data(): Bytes {
    let value = this.get("data");
    return value!.toBytes();
  }

  set data(value: Bytes) {
    this.set("data", Value.fromBytes(value));
  }
}

export class MetaTransactionExecuted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save MetaTransactionExecuted entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type MetaTransactionExecuted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("MetaTransactionExecuted", id.toString(), this);
    }
  }

  static load(id: string): MetaTransactionExecuted | null {
    return changetype<MetaTransactionExecuted | null>(
      store.get("MetaTransactionExecuted", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get userAddress(): Bytes {
    let value = this.get("userAddress");
    return value!.toBytes();
  }

  set userAddress(value: Bytes) {
    this.set("userAddress", Value.fromBytes(value));
  }

  get relayerAddress(): Bytes {
    let value = this.get("relayerAddress");
    return value!.toBytes();
  }

  set relayerAddress(value: Bytes) {
    this.set("relayerAddress", Value.fromBytes(value));
  }

  get functionSignature(): Bytes {
    let value = this.get("functionSignature");
    return value!.toBytes();
  }

  set functionSignature(value: Bytes) {
    this.set("functionSignature", Value.fromBytes(value));
  }
}

export class PredicateRegistered extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PredicateRegistered entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PredicateRegistered must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PredicateRegistered", id.toString(), this);
    }
  }

  static load(id: string): PredicateRegistered | null {
    return changetype<PredicateRegistered | null>(
      store.get("PredicateRegistered", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenType(): Bytes {
    let value = this.get("tokenType");
    return value!.toBytes();
  }

  set tokenType(value: Bytes) {
    this.set("tokenType", Value.fromBytes(value));
  }

  get predicateAddress(): Bytes {
    let value = this.get("predicateAddress");
    return value!.toBytes();
  }

  set predicateAddress(value: Bytes) {
    this.set("predicateAddress", Value.fromBytes(value));
  }
}

export class RoleAdminChanged extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleAdminChanged entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleAdminChanged must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleAdminChanged", id.toString(), this);
    }
  }

  static load(id: string): RoleAdminChanged | null {
    return changetype<RoleAdminChanged | null>(
      store.get("RoleAdminChanged", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get previousAdminRole(): Bytes {
    let value = this.get("previousAdminRole");
    return value!.toBytes();
  }

  set previousAdminRole(value: Bytes) {
    this.set("previousAdminRole", Value.fromBytes(value));
  }

  get newAdminRole(): Bytes {
    let value = this.get("newAdminRole");
    return value!.toBytes();
  }

  set newAdminRole(value: Bytes) {
    this.set("newAdminRole", Value.fromBytes(value));
  }
}

export class RoleGranted extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleGranted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleGranted must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleGranted", id.toString(), this);
    }
  }

  static load(id: string): RoleGranted | null {
    return changetype<RoleGranted | null>(store.get("RoleGranted", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class RoleRevoked extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RoleRevoked entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RoleRevoked must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RoleRevoked", id.toString(), this);
    }
  }

  static load(id: string): RoleRevoked | null {
    return changetype<RoleRevoked | null>(store.get("RoleRevoked", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get role(): Bytes {
    let value = this.get("role");
    return value!.toBytes();
  }

  set role(value: Bytes) {
    this.set("role", Value.fromBytes(value));
  }

  get account(): Bytes {
    let value = this.get("account");
    return value!.toBytes();
  }

  set account(value: Bytes) {
    this.set("account", Value.fromBytes(value));
  }

  get sender(): Bytes {
    let value = this.get("sender");
    return value!.toBytes();
  }

  set sender(value: Bytes) {
    this.set("sender", Value.fromBytes(value));
  }
}

export class TokenMapped extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TokenMapped entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TokenMapped must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TokenMapped", id.toString(), this);
    }
  }

  static load(id: string): TokenMapped | null {
    return changetype<TokenMapped | null>(store.get("TokenMapped", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get rootToken(): Bytes {
    let value = this.get("rootToken");
    return value!.toBytes();
  }

  set rootToken(value: Bytes) {
    this.set("rootToken", Value.fromBytes(value));
  }

  get childToken(): Bytes {
    let value = this.get("childToken");
    return value!.toBytes();
  }

  set childToken(value: Bytes) {
    this.set("childToken", Value.fromBytes(value));
  }

  get tokenType(): Bytes {
    let value = this.get("tokenType");
    return value!.toBytes();
  }

  set tokenType(value: Bytes) {
    this.set("tokenType", Value.fromBytes(value));
  }
}
